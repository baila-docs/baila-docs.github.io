<link href="../style.css" rel="stylesheet">

<h1>Урок 1. Основы</h1>

<h2>Оглавление</h2>
<ul>
	<li><a href="#var">Что такое переменная?</a></li>
	<li><a href="#types">Типы данных</a></li>
	<li><a href="#comments">Комментарии</a></li>
</ul>

<h2>Переменные</h2>

<a name="var"/>
<h3>Что такое переменная?</h3>

<p>Давайте представим, что у Вас есть два сундука, в одном Вы храните, скажем, драгоценности, а в другом - фотографии своей семьи. Внешне сундуки одинаковые, и узнать, что лежит в каждом сунуке, можно только по наклейке на самом сундуке - скажем, у первого наклейка будет гласить "драгоценности", а у второго - "фотографии семьи". Так вот, содержимое наклейки сундука будет именем переменной, содержимое сундука - значением переменной, а сам сундук - самой переменной.</p>
<p>Вы можете положить в сундук еще предметы, необязательно то, что написано на наклейке. В программировании это называется присваиванием значения переменной.</p>
<p>Давайте посмотрим, как же присвоить значение переменной в языке Baila:</p>
<code>x = 10</code>
<p>Здесь мы взяли сундук, наклеили на него наклейку "x" и положили туда число 10.</p>
<p>Можно взять пример посложнее:</p>
<code>x: Number = 123</code>
<p>Здесь мы взяли сундук, наклеили на него наклейку "x", положили туда число 10 и сказали сундуку, чтобы он принимал только числа. В программировании запрет переменной принимать значения любого типа (про типы мы поговорим позже), кроме того, который указан программистом, называется статической типизацией. Обратная же ситуация, когда переменная может принимать значения любого типа, называется динамической типизацией.</p>
<p>В чем же разница?<br>Рассмотрим два следующих обрывка кода:</p>
<pre>x = 10 # создали переменную x и присвоили x значение 10 (тип - число)
x = "hello" # присвоили x значение "hello" (тип - строка)</pre>
<pre>x: Number = 10 # создали переменную x с числовым типом и присвоили x значение 10 (тип - число)
x = "hello" # присвоили x значение "hello" (тип - строка)</pre>
<p>Второй обрывок кода не пройдет. Мы объявили x как числовую переменную, а пытаемся засунуть туда строку.</p>
<p>Имя переменной может начинаться с буквы, знака подчеркивания или доллара, продолжаться и заканчиваться ими же, а также цифрами. Цифра НЕ может быть в начале переменной, однако может быть в середине и конце.</p>
<p>Правильные названия переменной: abc, a1b2c3, _hello, _123 (первый символ все-таки _), $i, $100 (первый символ все-таки $).</p>
<p>Неправильные названия переменной: 5dollars (число нельзя ставить первым символом), ten% (знак процента не может использоваться в названии переменной, равно как и все остальное, кроме того, что разрешено двумя абзацами выше).</p>

<a name="types"/>
<h3>Типы данных</h3>

<p>В Baila существует всего 10 основных типов данных:</p>
<ul>
	<li>Number</li>
	<li>String</li>
	<li>Boolean</li>
	<li>List</li>
	<li>Dictionary</li>
	<li>Tuple</li>
	<li>Set</li>
	<li>Function</li>
	<li>Regex</li>
	<li>Object</li>
</ul>
<p>Поговорим про каждый из них по-отдельности.</p>

<p><b>Number</b> - числовой тип данных. Позволяет хранить целые, дробные числа, а также NaN (не число) и Infinity (бесконечность).</p>
<p>Все числовые литералы (простейшие единицы кода):</p>
<pre>x1: Number = 123 # целое положительное число
x2: Number = -500 # целое отрицательное число
x3: Number = 3.141592 # дробное положительное число
x4: Number = -1.618 # дробное отрицательное число
x5: Number = NaN # не число - единственный объект в Baila, который не равен самому себе
x6: Number = Infinity # положительная бесконечность, она больше любого числа, включая самого себя
x6: Number = -Infinity # отрицательная бесконечность, она меньше любого числа, включая самого себя</pre>

<p><b>String</b> - строковый тип данных. Позволяет хранить текст огромной длины - вплоть до двух гигабайт. Существуют также буквальные строки (строки, в которых не обрабатываются escape-последовательности) а также шаблонные строки (внутри которых можно вставить Baila код и он посчитается и вставится внутрь строки).</p>
<p>Все строковые литералы:</p>
<pre>s1: String = 'hello' # простая строка, заданная одинарными кавычками
s2: String = "hello" # простая строка, заданная двойными кавычками
s3: String = `hello` # буквальная строка - внутри нее escape-последовательности вроде \n, \r, \t, etc не будут обрабатываться.
s4: String = $'hello' # шаблонная строка, заданная одинарными кавычками
s5: String = $"hello" # шаблонная строка, заданная двойными кавычками
s6: String = $`hello` # шаблонная буквальная строка</pre>
<p>Что же такое escape-последовательности?</p>
<p>Представим, что Вам необходимо записать текст, состоящий из нескольких строк. Как Вы поступите? Конечно же, будете использовать escape-последовательность "\n":</p>
<code>str: String = "Hello,\nworld!"</code>
<p>В данном примере "Hello," будет на одной строчке, а "world!" на другой.</p>
<p>Такие последовательности работают в обычных и темплейт строках, образованными одинарной и двойной кавычкой. Строки и темплейт строки, образованные обратными (`) кавычками, обработают такую (да и другие) escape-последовательности <i>буквально</i>, из-за чего и получили свое название - буквальные строки.</p>
<p>Темплейт строки работают следующим образом: внутри строки внутри символов {} любой текст обрабатывается как Baila код и его возвращаемое значение подставляется вместо символов {} и того, что внутри них.</p>
<p>К примеру, нам нужно вывести список пользователей сайта через запятую:</p>
<pre>x: List&lt;String&gt; = ["Alan", "Alex", "Bob", "Sally", "Tom"] # создали список строк, содержащий 5 имен пользователей сайта.
users: String = $"Site users: {x.join(', ')}. Greet them!" # создаем строку и вставляем в нее пользователей сайта через запятую</pre>
<p>Код выше полностью эквивалентен нижнему:</p>
<pre>x: List&lt;String&gt; = ["Alan", "Alex", "Bob", "Sally", "Tom"]
users: String = "Site users: " + x.join(', ') + ". Greet them!"</pre>

<p><b>Boolean</b> - булевый, или логический, тип данных. Может хранить только два значения - true (правда) и false (ложь).</p>
<p>Настоятельно рекомендуется использовать Boolean для правдивых значений вместо Number (1 и 0).</p>
<p>Все булевые литералы:</p>
<pre>b1: Boolean = true # правда
b2: Boolean = false # ложь</pre>

<p><b>List</b> - список. Если не указан &lt;Тип&gt; списка (в угловых скобках), то список может принимать любое значение, иначе только то, что содержится в угловых скобках.</p>
<p>Некоторые из возможных списковых литералов:</p>
<pre>l1: List = [1, 2, "hello", true, [3, 4, "world", [false]]] # тип списка не указан, можно хранить все, что угодно, вплоть до других списков бесконечной вложенности.
l2: List&lt;Number&gt; = [1, 2, 3, 4] # тип списка указан как Number, можно хранить только числа
l3: List&lt;type Number|String&gt; = [1, "hello", 3, "world"] # тип списка указан как Number|String, можно хранить только числа и строки
l4: List&lt;type range 1..10&gt; = [1, 5, 10] # тип списка указан как range 1..10, можно хранить только числа от 1 до 10</pre>

<p><b>Dictionary</b> - словарь. Если не указан &lt;ТипКлюча, ТипЗначения&gt; (в угловых скобках), то словарь может принимать ключи и значения только соответствующих типов; если указан только &lt;ТипЗначения&gt;, то ключи могут быть любыми, а значения только указанного типа; если не указаны угловые скобки сообще, то ключи и значения могут быть произвольных типов.</p>
<p>Некоторые из возможных словарных литералов:</p>
<pre>d1: Dictionary = {1: "value1", "key2": [2, "value2"]} # тип словаря не указан, можно ключи и значения любого типа
d2: Dictionary&lt;List&gt; = {"s1": [1, 2, 3], 2: ["value2", 12, 34]} # указан только тип значения - список, ключи могут быть произвольными
d3: Dictionary&lt;Number, List&lt;String&gt;&gt; = {1: ["hello", "world"], 2: ["you", "are", "beautiful"]} # тип ключа - число, тип значения - список строк. Как видите, угловые скобки могут быть бесконечной вложенности, если требуется.</pre>

<p><b>Tuple</b> - кортеж. Можно считать его неизменяемым списком - после создания сам кортеж невозможно изменить, в то время как список является изменяемым. Кортежу также можно задать тип в виде дженерика (к примеру, Tuple&lt;String&gt; - кортеж, который может хранить только строки).</p>
<p>Некоторые из возможных кортежных литералов:</p>
<pre>l1: Tuple = (1, 2, (), "hello", true, [3, 4, "world", (false,)]) # тип списка не указан, можно хранить все, что угодно.
# обратите внимание на третий элемент, который является пустым кортежем, а также на элемент '(false,)' - для создания кортежа с одним элементом требуется ставить запятую после значения, иначе (false) бы посчиталось как false в скобках.
l2: Tuple&lt;Number&gt; = (1, 2, 3, 4) # тип кортежа указан как Number, можно хранить только числа
l3: Tuple&lt;type Number|String&gt; = 1, "hello", 3, "world" # тип кортежа указан как Number|String, можно хранить только числа и строки. Скобки в присваивании кортежа писать необязательно (однако в вызовах функции и в других местах, где запятая значит разделитель значений, писать скобки нужно обязательно).
l4: Tuple&lt;type range 1..10&gt; = 1, 5, 10 # тип кортежа указан как range 1..10, можно хранить только числа от 1 до 10</pre>
<p>С помощью кортежа и деструктурирующего присваивания можно поменять значения переменных одной строкой:</p>
<pre>x = 1
y = 2
x, y = y, x # деструктурирующее присваивание: элементу x соответствует первый элемент кортежа (y, x) - y, а элементу y соответствует второй элемент кортежа (y, x) - x
print(x) # выведет 2
print(y) # выведет 1</pre>

<p><b>Set</b> - множество. Изменяемое, упорядоченное. Можно считать его списком с уникальными значениями - при добавлении во множество элемента, который уже есть во множестве, ничего не произойдет. Также можно удалить элемент одной командой. Как и другие типы-контейнеры, может быть либо нетипизированным, либо типизированным. В типизированном множестве тип содержащихся в нем элементов также указывается внутри дженерика (угловых скобок).</p>
<p>Множество создается командой new Set, также может быть проинициализировано в фигурных скобках:</p>
<pre>s1: Set = new Set # создали пустое нетипизированное множество
s2: Set&lt;Number&gt; = new Set&lt;&gt; # использовали 'diamond-оператор' - тип значения по правую сторону присваивания будет смотреться по типу переменной на левой стороне.
s3: Set = new Set {1, 2, "hello", 3, 4, "hello"} # создали нетипизированное множество и сразу инициализировали его. Так как во множестве никак не может быть двух и более одинаковых значений, второе "hello" отбрасывается, таким образом s3 === new Set { 1, 2, "hello", 3, 4 }.
s4: Set&lt;String&gt; = new Set&lt;&gt; { "hello", "world" } # создали типизированное множество и сразу инициализировали его.</pre>

<p><b>Function</b> - функция. Может быть как нетипизированной (принимать любое кол-во значений любых типов и возвращать что угодно (а может и вообще не возвращать ничего)), так и типизированной (все аргументы дженерика, кроме последнего, отвечают за типы аргументов, а последний - за возвращаемый тип. Если требуется функция, которая принимает аргументы, а значение не возвращает, используйте вместо имени типа null или undefined).</p>
<p>Именованная функция создается так:</p>
<pre>function sum(x: Number, y: Number): Number {
	return x + y
}</pre>
<p>В данном примере мы создали функцию sum, принимающую два параметра - x и y, и возвращающую число - сумму этих двух аргументов.</p>
<p>Впоследствии мы можем вызвать эту функцию так:</p>
<code>print(sum(5, 10)) # выведет 15</code>
<p>Также можно создать переменную, содержащую функцию. Обычно такие функции неименованные, то есть анонимные:</p>
<pre>sum = function(x: Number, y: Number): Number {
	return x + y
}</pre>
<p>Пример выше для разработчика не отличается ничем от первого примера.</p>
<p>Также можно передавать функцию в качестве аргумента другой функции:</p>
<pre>function callFunc(f: Function) {
	f()
}
function myFunc { # если параметров нет, можно написать либо (), либо вообще опустить скобки
	print("myFunc")
}
callFunc(myFunc) # выведет myFunc
callFunc(function { print("func2") }) # выведет func2</pre>
<p>Также стоит заметить, что ключевые слова func и function в Baila полностью равнозначны:</p>
<pre>print(func { } === function { }) # выведет true</pre>
<p>Также существует стрелочный синтаксис функции (называемый лямбда):</p>
<pre>sum = (x, y) => x + y
#     ^^^^^^ ^^ ^^^^^
#       |    |    |
#       |    |  возвращаемое значение
#       |    |
#       |  оператор стрелочка
#       |
#     список параметров
print(sum(7, 3)) # выведет 10</pre>
<p>Для одного аргумента скобки в описании можно опустить:</p>
<pre>sqr = num => num * num
print(sqr(10)) # выведет 100</pre>

<p><b>Regex</b> - регулярные выражения, которые используются для сложных шаблонов: к примеру, входит ли подстрока из пяти символов a, b или c в строку, а также получить эти 5 символов в переменную.</p>
<p>Объект регулярного выражения можно создать двумя путями: через литерал и через конструкцию new:</p>
<pre>regex1: Regex = /^[a-z]{3}/i # регекс, который проверит, начинается ли строка с трех латинских букв
regex2: Regex = new Regex('^[a-z]{3}', 'i') # тот же самый регекс, только в виде инстанциирования класса</pre>
<p>Проверка строки на соответствие шаблону делается методом test на регексе либо на строке (другой объект нужно будет передать параметром функции):</p>
<pre>regex: Regex = /^[a-z]{3}/i # регекс из предыдущего примера
str1: String = "John" # эта строка подходит под шаблон
str2: String = "G00d" # эта строка не подходит под шаблон, ибо латинская буква - только первый символ, следующие два - цифры
print(regex.test(str1)) # Выведет true
print(regex.test(str2)) # Выведет false
print(str1.test(regex)) # Выведет true
print(str2.test(regex)) # Выведет false</pre>

<p><b>Object</b> - объект, суперкласс любого другого типа и инстанса типа. Все в Baila - объект и все классы явно или неявно наследуются от класса Object.</p>
<p>У Object есть методы. Эти методы передаются во все остальные классы:</p>
<pre>o: Object = new Object # создаем пустой объект
print(o.toString()) # выведет [object Object]. Этот метод, как и остальные методы Object, может быть переопределен в дочерних классах.</pre>

<a name="comments"/>
<h2>Комментарии</h2>

<p>Комментарий - часть кода, которая полностью игнорируется интерпретатором, то есть Вы можете написать там что угодно - пометку себе на человеческом языке, либо код, который не выполнится никогда.</p>
<p>В Baila есть два вида комментариев: однострочные и двустрочные.</p>

<h3>Однострочный комментарий</h3>

<p>Такой комментарий начинается с символа решетки и идет до конца строки. Они удобны для пометки того, что делает данная строка, но также может использоваться и для других целей.</p>
<pre>x = 10 # создать переменную x со значением 10
# x = 15 - это не выполнится, потому что закомментировано.</pre>

<h3>Многострочный комментарий</h3>

<p>Такой комментарий начинается с символов /* и заканчивается символами */. Такие комментарии удобны для закомментирования большого количества строк или создания документации, которая будет выводиться в автодополнении IDE.</p>
<pre>/* x = 10 этот код не выполнится
print("Hello") этот тоже */</pre>

<script src="../simple_highlight.js"></script>